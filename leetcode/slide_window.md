# 滑动窗口解析
## 概述




## 经典题型
### 76. 最小覆盖子串
给你一个字符串 S、一个字符串 T 。请设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。

#### 示例：
```
输入：S = "ADOBECODEBANC", T = "ABC"
输出："BANC"
```

#### 提示：
```
如果 S 中不存这样的子串，则返回空字符串 ""。
如果 S 中存在这样的子串，我们保证它是唯一的答案。
```

#### 思路
- 采用双指针维护一个滑动窗口，通过窗口扩充和收缩寻找到一个满足要求的字串，并维护当前最小字串的起始位置和长度。
- 使用 unordered_map 保存子串，用来O(1)复杂度验证字符是否属于子串
- 使用 unordered_map 记录窗口内保存的字符，由于字符可能重复，value值为字符出现的次数。
- 右指针向右移动，寻找目标字符，当找到全部目标字符时，停止右移，此时窗口内是存在冗余的。
- 左指针向右移动，收缩窗口消除冗余，只到窗口不包含全部字符为止，每次移动前都更新最小子串的起始位置和长度。

#### 代码
```
string minWindow(string s, string t) {
    int left = 0, right = 0, start = 0, minLen = INT_MAX;
    unordered_map<char, int> need;
    unordered_map<char, int> window;
    for (char c : t) {
        need[c]++; // 目标字符数
    }
    int match = 0;
    while (right < s.size()) { // 滑窗开始
        char c1 = s[right];
        if (need.count(c1)) { // 当前字符为目标字符
            window[c1]++; // 更新窗口内字符数
            if (window[c1] == need[c1]) { // 若改字符的窗口内字符数 = 需要的目标字符数，匹配字符数加一
                match++;
            }
        }
        right++; // 窗口右扩
        while (match == need.size()) { // 当窗口内的所有字符均已匹配完成，开始窗口左侧缩窗
            if (right - left < minLen) { // 更新当前窗口最小值及窗口起始位置
                minLen = right - left;
                start = left;
            }
            char c2 = s[left];
            if (need.count(c2)) { // 若左侧字符为目标字符
                window[c2]--; // 更新窗口内字符统计
                if (window[c2] < need[c2]) { // 窗口变更后不满足目标字符数要求，匹配字符数减一，循环结束，重新开始新一轮右扩
                    match--;
                }
            }
            left++; // 窗口左缩
        }
    }
    return minLen == INT_MAX ? "" : s.substr(start, minLen);
}
```

### 438. 找到字符串中所有字母异位词
给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。

#### 说明：
- 字母异位词指字母相同，但排列不同的字符串。
- 不考虑答案输出的顺序。

#### 示例1

```
输入:
s: "cbaebabacd" p: "abc"

输出:
[0, 6]

解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。
```

#### 示例2
```
输入:
s: "abab" p: "ab"

输出:
[0, 1, 2]

解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。
```

#### 思路
