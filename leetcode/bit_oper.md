# 位运算
## 前言
位运算包括与(&)、或(|)、非(~)、异或(^)、位移等位运算。

### 技巧规则
#### n & (n -1)
- 判定是否是2的幂次方，结果等于 0 则 n 为 2 的幂次方（2,4,8,16……）。
- 消除 n 的二进制表示的最后一个1。

## 与运算
### 191. 位1的个数
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数

#### 思路
- 利用 n & (n-1)的第二个用法，每次消除一个1，循环累加。

#### 代码
```
int hammingWeight(uint32_t n) {
    int res=0;
    while(n!=0){
        n=n&(n-1);
        ++res;
    }
    return res;
}
```
### 342. 4的幂
给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。

#### 思路
- 4 的幂次方，一定也是 2 的幂次方，也就是说二进制中只能有一个 1。
- 4 的幂次方，1 一定是在奇数位上，所以先判定是不是2的幂次方，然后判定1是否在奇数位上。

#### 示例 1:
```
输入: 16
输出: true
```

#### 代码
```
bool isPowerOfFour(int num) {
    if (num < 0 || num &(num-1) )
        return false;
    return num & 0x55555555;
}
```

### 201. 数字范围按位与
给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。

示例 1: 
```
输入: [5,7]
输出: 4
```

#### 思路
- 从高位向低位与，利用 n&(n-1)的特性： n & (n - 1) 可以将 n 最右边的 1 变成 0
- 将 n 从右到左的 1 循环去掉，只到不大于 m ，然后 m 和 n 直接与运算。

#### 代码
```
int rangeBitwiseAnd(int m, int n) {
	while (m < n) {
		n = n & (n-1)
	}
	return m & n;
}
```

