# 位运算
## 前言
位运算包括与(&)、或(|)、非(~)、异或(^)、位移等位运算。

### 技巧规则
#### n & (n -1)
- 判定是否是2的幂次方，结果等于 0 则 n 为 2 的幂次方（2,4,8,16……）。
- 消除 n 的二进制表示的最后一个1。

## 与运算
### 191. 位1的个数
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数

#### 思路
- 利用 n & (n-1)的第二个用法，每次消除一个1，循环累加。

#### 代码
```
int hammingWeight(uint32_t n) {
    int res=0;
    while(n!=0){
        n=n&(n-1);
        ++res;
    }
    return res;
}
```
### 342. 4的幂
给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。

#### 思路
- 4 的幂次方，一定也是 2 的幂次方，也就是说二进制中只能有一个 1。
- 4 的幂次方，1 一定是在奇数位上，所以先判定是不是2的幂次方，然后判定1是否在奇数位上。

#### 示例 1:
```
输入: 16
输出: true
```

#### 代码
```
bool isPowerOfFour(int num) {
    if (num < 0 || num &(num-1) )
        return false;
    return num & 0x55555555;
}
```

### 201. 数字范围按位与
给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。

示例 1: 
```
输入: [5,7]
输出: 4
```

#### 思路
- 从高位向低位与，利用 n&(n-1)的特性： n & (n - 1) 可以将 n 最右边的 1 变成 0
- 将 n 从右到左的 1 循环去掉，只到不大于 m ，然后 m 和 n 直接与运算。

#### 代码
```
int rangeBitwiseAnd(int m, int n) {
	while (m < n) {
		n = n & (n-1)
	}
	return m & n;
}
```

## 异或(^)
### 136. 只出现一次的数字
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

#### 示例
```
输入: [4,1,2,1,2]
输出: 4
```
#### 思路
- 采用异或的特性，相同数字互相抵消，剩余的就是只出现了一次的数字
#### 代码
```
int singleNumber(vector<int>& nums) {
    for (int i = 1; i < nums.size(); i++) {
        nums[0] ^= nums[i];
    }
    return nums[0];
}
```

### 461. 汉明距离
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

#### 思路
- x 和 y 异或，然后计算 1 的个数。

#### 代码
```
int hammingDistance(int x, int y) {
    x = x ^ y;
    int count = 0;
    while (x > 0) {
        x = x & (x-1);
        count++;
    }
    return count;
}
```
