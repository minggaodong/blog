# 位运算
## 前言
位运算包括与(&)、或(|)、非(~)、异或(^)、位移等位运算。

### 技巧规则
#### n & (n -1)
- 判定是否是2的幂次方，结果等于 0 则 n 为 2 的幂次方（2,4,8,16……）。
- 消除 n 的二进制表示的最后一个1。

## 与运算
### 191. 位1的个数
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数

#### 思路
- 利用 n & (n-1)的第二个用法，每次消除一个1，循环累加。

#### 代码
```
int hammingWeight(uint32_t n) {
    int res=0;
    while(n!=0){
        n=n&(n-1);
        ++res;
    }
    return res;
}
```
### 342. 4的幂
给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。

#### 思路
- 4 的幂次方，一定也是 2 的幂次方，也就是说二进制中只能有一个 1。
- 4 的幂次方，1 一定是在奇数位上，所以先判定是不是2的幂次方，然后判定1是否在奇数位上。

#### 示例 1:
```
输入: 16
输出: true
```

#### 代码
```
bool isPowerOfFour(int num) {
    if (num < 0 || num &(num-1) )
        return false;
    return num & 0x55555555;
}
```

### 201. 数字范围按位与
给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。

示例 1: 
```
输入: [5,7]
输出: 4
```

#### 思路
- 当一个数+1时，总会有这么一个规律“某一位后的数字，全部被置为相反数
- 当(m,m+1,...n-1,n)进行连续“与操作”时，会按照上述规律被抵消很大一部分，而只剩下n的前缀部分，最后只需将n归位
- m = 5(0101), n = 7 (0111)。不停右移，得到n前缀部分为01，最后归位前缀得res=0100=4

#### 代码
```
int rangeBitwiseAnd(int m, int n) {
    int offset = 0;
    for (; m != n; ++offset) {
        m >>= 1;
        n >>= 1;
    }
    return n << offset;
}
```

