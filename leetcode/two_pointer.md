# 双指针详解
## 概述
双指针是面对数组、链表结构的一种处理技巧，这里“指针”是泛指，不但包括普通指针，还包括索引、迭代器等可用于遍历的游标。

双指针可以分为
- 同方向指针
- 反方向指针
- 快慢指针

##  同方向指针
设定两个指针、从头往尾(或从尾到头)遍历，称之为同方向指针，第一个指针用于遍历，第二个指针满足一定条件下移动。

### 283. 移动零
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
#### 示例:
```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```
#### 思路
- 采用双指针，右指针遍历元素，左指针始终指向第一个0值，遍历数组对非0元素进行交换。
- 遍历过程中，遇到0值跳过，遇到非零值就和左指针交换，难点是要维护左指针始终能指向第一个0值。

#### 代码
```
void moveZeroes(vector<int>& nums) {
    int l = 0, r = 0;
    for (; r < nums.size(); r++) {
        if (nums[r] != 0) {
            if (nums[l] == 0) {
                nums[l] = nums[r];
                nums[r] = 0;
            }
            l++;
        }
    }
}
```

### 26. 删除排序数组中的重复项
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

#### 示例1:
```
给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
```

#### 示例 2:
```
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```

#### 思路
- 采用双指针，右指针遍历元素，左指针始终指向无重复序列的最后一个元素
- 每遍历一个元素，都判断是否大于左指针，如果等于左指针，则重复元素直接跳过
- 如果大于左指针，则和左指针的下一个元素进行交换，并将左指针指向下一个元素。

```
int removeDuplicates(vector<int>& nums) {
    if (nums.size() < 2)
        return nums.size();

    int l = 0, r = 0;
    for (; r < nums.size(); r++) {
        if (nums[r] > nums[l]) {
            nums[++l] = nums[r];
        }
    }

    return l+1;
}
```

### 80. 删除排序数组中的重复项 II
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。
#### 示例
```
给定 nums = [0,0,1,1,1,1,2,3,3],

函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。

你不需要考虑数组中超出新长度后面的元素。
```
#### 思路
- 采用上一题思路，只不过移动时判断前一个元素是否重复

#### 代码
```
int removeDuplicates(vector<int>& nums) {
    if (nums.size() < 3)
        return nums.size();

    int l = 0, r = 0;
    for (r = 1; r < nums.size(); r++) {
        if (nums[r] != nums[l]) {
            nums[++l] = nums[r];
        } else {
            // 相等时，判断l前一个元素
            if ((l == 0 || nums[l] != nums[l-1])) {
                nums[++l] = nums[r];
            }
        }
    }

    return l+1;
}
```
