STL标准库
STL(标准模板库)，是目前C++内置支持的library。它的底层利用了C++类模板和函数模板的机制，由三大部分组成：容器、算法和迭代器。

STL六大组件
容器 container
算法 algorthm
迭代器 iterator
仿函数 function object
适配器 adaptor
空间配置器 allocator

容器
vector向量
deque双端数组
stack栈模型
queue队列模型
list链表模型
priotriy_queue优先级队列
set与multiset容器
map与multimap容器

迭代器
迭代器是一种抽象的设计概念，提供了访问某个容器内部元素的方法，但无需要暴漏该容器的内部结构，它将容器和算法分开，好让这二者独立设计。
迭代器是一种类似于指针的存在，迭代器最重要就是对operator*和operator->进行重载。
迭代器设计了一套规范，STL每种容器都有自己的迭代器，但是它们都实现了相同的接口。在使用者看来，迭代器的使用时统一的。
对map和list的插入(insert)和删除(erase)操作，则导致迭代器失效，需要这样获取新的迭代器：iter = container.erase(iter)。
vector使用迭代器操作时，一旦发生了扩容，则指向原vector的所有迭代器都将失效。

allocator
容器的内存分配是基于allocator实现，大部分STL版本（比如SGI）实现allocatior时，其实就是简单的封装了new/delete，并没有实现什么内存池。
malloc()系统调用本身有内存池的实现，性能还可以，如果对性能要求高，可以用第三方内存池库重新实现allocator，所以STL默认的allocator没有采用内存池技术。

vector内存分配
vector底层采用动态数组实现，其中capacity()返回的是容器分配的内存大小，size()返回的是实际存储的元素个数。
vector动态扩容时，会按倍数重新申请空间，并将原来数据拷贝到新内存。在vs编译器下是按1.5倍扩容，在gcc下是按2倍扩容，具体用几倍是时间和空间上的一个权衡。
vector之所以不再尾部重新开辟内存，是因为无法保证原空间之后尚有可供配置的空间。
vector采用倍数扩容，是为了让push_back的均摊（amortized）时间复杂度为常数时间O(1)，如果是固定数扩容，则均摊时间复杂度为O(N)。
1.5倍的优势是分配几次后，下次分配的内存，肯定小于之前分配的内存总和，可以直接复用原来的内存，2倍的话，下次分配的内存一定大于之前分配的内存总和，没法重复利用。
2倍的好处是，linux采用伙伴系统管理物理内存，伙伴系统维护的空闲内存块是按2的倍数个页框连续存储的，2倍扩容可以使得刚好占用一个页框块。避免在物理内存上产生内存碎片。
