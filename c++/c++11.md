# C++11 新特性
## 类型推导 auto
auto 定义变量时，相当于一个类型占位符，编译器在编译期间会自动推导出变量实际类型并替换。

auto 最常用的场景是和 C++11 中的新式 for 循环，还有 lambda 表达式进行配合使用。

auto 使用规则
- auto 只能用于定义，不能用于声明，必须可推导。
- auto 不能用于函数的形参。
- auto 不能用来声明数组。
- auto 声明指针时，auto 和 auto* 没有区别，但是用 auto 声明引用时必须加 & 。

```
// 用于定义变量
std::map<int, std::string> m;
auto itr = m.find(1);

// 用于循环
std::vector<std::string> v;
for (const auto& t : v) {
  std::cout << t;
}

for (const auto& t : m) {
  std::cout << t.first << t.second;
}
```

## 新式 for 循环
支持通过 auto 关键字的新式循环，参考上面 auto 的例子。

## 类成员变量可定义初始值
成员变量定义时可以赋初始值，在构造函数之前被设置，如果构造函数包含初始化列表，则替换为初始化列表的参数值。
```
class A {
private: 
  int a_ = 1; // 可以直接定义初始值
}
```

## 创建和删除构造函数
当类自定义了构造函数后，编译器不再创建默认构造函数，采用default关键字可以强制让编译器创建默认构造函数。

有时候不想要构造函数，比如单例模式把构造函数声明为private类型，这时候可以使用delete关键字删除默认构造函数。
```
class A {
public:
    A() = default; // 创建默认构造函数
    A() = delete;  // 删除默认构造函数
};
```

## lambda 表达式
lambda 其实就是匿名函数，支持定义一个临时函数对象，可以传递和保存，而且可以捕获当前函数的上下文。

lambda 表达式格式： auto lambda1 = [](){};
- [] 代表捕获的外部变量，为空则表示不捕获外部变量。
- () 函数的参数，和普通函数的形参定义一样。
- {} 函数的具体内容。

捕获类型
- [] 不捕获任何外部变量
- [a]	a为值传递
- [a, &b]	a为值传递，b为引用传递
- [&]	所有变量都用引用传递。当前对象（即this指针）也用引用传递。
- [=]	所有变量都用值传递。当前对象用引用传递。

```
int main() {
  int m = 1;
  auto add = [m](int a, int b) {
          return a + b + m;
  };
  
  m = 2;
  std::cout << add(1,1) << std::endl; // 这里输出的是3，而不是4，因为m捕获的值为1
  return 0;
}
```

## 右值引用
右值引用是通过语义转义的方式，将等号右边的临时对象的所有权转移给左值，避免临时对象的内存拷贝。

右值引用用 && 表示，是对右侧临时对象的引用，右值引用后的变量是一个左值，可以像左值一样操作。

左值和右值
- 所有的变量都是左值
- 等号右边的非变量都是右值，比如 int a = 1 + 2; a是左值，1+2 是右值。
- 总结：凡是没法获取地址的值都是右值。
- 可以通过 std::move(左值)得到一个右值引用。

```
int a = 1;    // a 是左值，1 是右值
int &b = a;   // 左值引用
int &c = 1;   // 错误，左值引用必须引用变量

int &&d = 1;      // 右值引用
int &&e = 1 + a;  // 右值引用
int &&f = a;      // 错误，右值引用只能引用临时变量

e = d + e;
std::cout << e;   // 输出3

int &&f = std::move(a); // 将左值变成一个右值引用
```

## 语义转移
std::move() 是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝，可以提高性能。

它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。

```
std::vector<std::string> v;
str = "hello";
v.push_back(str);             // copy
v.push_back(std::move(str));  // move，性能更高
```

## emplace_back
当调用容器的 push_back 或 insert 成员函数时，是把元素类型的对象传递给它们，这些对象被拷贝到容器中。

当调用容器的 emplace系列函数时，则是将相应参数传递给元素类型的构造函数，这样就不需要对象的拷贝，可以提升容器插入性能。

## 线程库
c++11 提供了专门的线程库，但是由于底层还是封装的 pthread 库，所以要加 -lpthread 链接选项。
```
#include <thread>

// 定义线程函数，参数可以随意指定多个
void work(int param1, int param2) {
}

// 创建线程并执行
std::thread myThread = std::thread(&work, param1, param2);

// 等待线程结束
if (myThead.joinable())
  myThead.join();
```

## atomic 原子操作
atomic 对 int、char、bool 等数据结构进行了原子性封装，在多线程环境中，利用 std::atomic 可实现数据结构的无锁设计。

std::atomic 的原子性操作是由编译器来保证的，编译器确保任意时刻只有一个线程对这个资源进行访问。

```
#include <atomic>

// 定义一个支持原子操作的整数变量 count
std::atomic<size_t> count(0);

// 多线程下的 ++ 运算，对 count 来说是线程安全的 
void threadFun() {
	for (int i = 0; i < 10000; i++)
		count++;
}
```

## thread_local
thread_local 描述的变量，是 thread 的私有变量，其他 thread 没法访问的。

thread_local 对象在 thread 开始的时候进行分配，thread 结束的时候进行分解。

thread_local 描述类成员变量的时候，必须是 static 。

```
#include <iostream>
#include <thread>
#include <mutex>

// 定义一个 thread_local 变量
std::thread_local int x = 1;

// 各个线程的 x 值互相不影响
void func() {
    for(int i = 0 ; i < 4; i++) {
        x++;
        printf("%ld: %d\n",std::this_thread::get_id() , x);
    }
}

int main() {
    std::thread t1(func);
    std::thread t2(func);
    t1.join();
    t2.join();
    return 0;
}
```
