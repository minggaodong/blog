# Redis 详解

## Redis 简介
Redis（Remote dictionary server）是一个 key-value 存储系统，与 Memcached 一样为了保证效率，将数据存储在内存中，区别是 Redis 有持久化和主从同步机制，数据不易丢失。

### Redis 特点
- 读写速度快：单机可达10万每秒，读速度比写速度略快。

- 丰富的数据结构：支持包括字符串，哈希表，集合，有序集合，列表等多种数据结构。

- 原子操作和事务：支持分布式锁，支持原子操作和事务操作。

- 丰富的特性：发布订阅，key过期自动删除，bitmap等。

### Redis 缺陷
#### 持久化功能体验不佳
故障恢复时间长，采用 rdb 或 aof 做持久化，当容量达到 50G 时，大约需要 40~70分钟。

#### 主从切换代价大
主库挂掉，从库升级为主库，其他从库会做一次全同步。

#### 缓冲区写满问题
主从之间网络延迟，从库同步不及时，主库会为每一个从库缓存一份增量请求，当缓冲区写满，会导致全同步。

#### 不满足强一致性，数据存在丢失的可能
- redis 支持 aof 持久化机制，但是为保证性能，采用异步来写磁盘，如果机器 down 机，写入到页缓存来不及刷新磁盘。
- redis 向从库同步数据时，也是采用异步发送，如果主库挂掉，没来得及同步到从库的数据也会丢失。

#### 缓存击穿问题
- 缓存击穿是指某一时刻，缓存中没有(可能过期)但数据库中有该数据，此时大量请求去数据库读取该数据，造成数据库压力太大。
- 解决方案是，热点数据设置永不过期，同时加互斥锁，保证同一时刻只能有一个请求访问数据库数据，其他的请求等待数据更新到缓存后，去缓存取数据。

#### 缓存雪崩问题
- 即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。
- 解决方案是，给缓存失效时间加一个随机值，避免集体失效，还有就是双缓存，过期时间设置的不一样。

## 底层数据结构
redis 的底层数据结构主要是字典和跳表，字典无序，跳表为有序。

redis 为了节约内存，牺牲了少量的查找性能，设计了整数集合和压缩列表两种结构，整数集合是以整型数组有序存储，压缩列表是二进制顺序存储，在元素较少时，可以使用这两种结构。

### 字符串
- 常数复杂度获取字符串长度
- 杜绝缓冲区溢出：sds 内置一个sdscat 函数，用于字符串拼接，在执行前会检查空间是否足够。
- 减少内存分配次数：采用空间预分配(2倍增长)和惰性删除实现。

### 链表
- 双向链表
- 带表头指针和尾指针
- 带链表长度计数器
- 多态：链表使用void*来保存节点值，可以保存不同类型的值。

### 字典
- 基于 hash 表实现，每个字典有两个 hash 表，hash[0] 正常使用，hash[1] 用于 rehash 期间使用。
- 采用链地址法解决冲突：被分配到同一个地址的键会构成一个单向链表。
- 字典是集合键和哈希键的退化实现。

### 跳跃表
- 跳跃表是一种有序的数据结构，平均时间复杂度 O(logN)，能够代替平衡二叉树，且在内存占用，插入和实现难易度上更有优势。

### 整数集合(intset)
- 采用有序整型数组存储，查找时采用二分查找，时间复杂度O(logN)，插入和删除复杂度为O(N)，节约内存。
= 集合键的默认实现，当元素个数超过512或元素为非整数时，退化为字典存储。

### 压缩列表(ziplist)
- 压缩列表是一块连续的内存，查找和修改都需要 O(n) 的复杂度，适合保存整数和短字符串，整数是按二进制方式存储，节约内存。
- hash 键的默认实现，当元素个数超过 512 或者单个 key 长度超过 64 字节时，退化为字典存储。
- 有序集合键的默认实现，当元素个数超过 128 或者单个元素长度超过 64 字节时，退化为跳表存储。

## 持久化策略
### Rdb 持久化
- 内存快照，定时 fork 一个子进程，将数据以二进制形式备份，可手动调用 bgsave 命令执行备份。
- 特点是备份文件冗余小，恢复效率高，可以将备份文件定期转移避免机器故障；但是及时性低，故障时会丢一部分数据。

### Aof持久化
- 将命令写入文件，支持同步和异步刷磁盘，当 aof 文件大小超过配置时，会执行 rewrite 去除冗余命令，rewrite 时也是 fork 一个子进程，采用写时复制创建一个新的 aof 文件。
- 特点是数据安全性高，几乎不丢数据(配置为同步刷新磁盘不丢数据)；但是备份文件冗余大，恢复太慢，所以尽量不采用。

### 策略选择
- 单机模式下，基于不同的安全等级选择：不开启持久化 < 只开启Rdb < 只开启Aof(宕机或磁盘损坏丢失) < Rdb和Aof同时开启。
- 主从架构下，主库不做任何持久化，只在从库上根据安全等级选择持久化策略；恢复时，在从库做一次bgsave，将rdb文件拷贝到主库，重启主库恢复。
- 当 redis 中途开启 AO f时，在重启 redis 服务前一定要拷贝一份当前的 rbd 文件，因为重启后会优先读取.aof文件，当第二次重启时，会将 aof 文件的数据存储到 dump.rdb 文件当中，这就会造成数据的丢失。

## 过期删除策略
### 定期删除
每隔 100ms 就随机抽取一批设置过期时间的 key，检测是否过期并删除。

### 惰性删除
当 key 被访问时，检查是否过期并删除。

## 内存淘汰策略
### noeviction（不推荐）
- 禁止写入新数据，会报错。

### volatile-lru （不推荐）
- 在设置了过期时间的键空间中，基于LRU（最近最少使用）删除key。
- 这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。

### allkeys-lru（推荐）
- 在设置了过期时间的键空间中，基于LRU（最近最少使用）删除key。

### lru采样
- redis 的 LRU 和常规不同，不是一个精确的实现，而是使用采样，在采样的键值中选出最近没有使用的一个key删除。
- 测试表明，设置样本数为10时，能够很准确的淘汰掉最久没有使用的 key，与常规 LRU 持平。

## 主从同步机制
- 从库启动时发送 sync 命令给主库，主库做一次 bgsave，生成 rdb 文件，并发送给从库实现全同步；之后将增量请求异步发送给从库，实现增量同步。
- 如果从库网络延迟，主库会将增量数据缓存起来，但是当缓冲区满时，会执行全同步。
- 主从同步机制会对主库性能造成压力，当有多个从库时，推荐线性配置。

## redis 问答
### 单进程单线程的 redis 如何能够高并发
- 采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）。

### 为什么不采用多进程或多线程处理？
- 多线程处理可能涉及到锁
- 多线程处理会涉及到线程切换而消耗CPU。

### 单线程处理的缺点
- 无法发挥多核 CPU 性能，不过可以通过在单机开多个 redis 实例来完善。

### redis为什么这么快
- 绝大部分请求是纯粹的内存操作
- 单线程，避免了不必要的cpu上下文切换和加锁竞争
- 非阻塞IO多路复用
