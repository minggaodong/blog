# linux 各种锁总结
## 锁的原理
### cpu 原子指令
cpu 提供的原子指令是构建锁的基础，比如 x86 的 CMPXCHG（LOCK 前缀）实现了 CAS（Compare and Swap ）原子操作。

指令带有 LOCK 前缀，修改数据时会锁定系统总线或某一块 cache line，保证只能有一个核对同一块内存地址赋值。

现代 cpu 优先使用 cache line 缓存锁定（通过缓存一致性实现），如果缓存不命中或者占用多个 chache line，则采用总线锁定。

### futex
futex (fast userspace mutex) 是 Linux 的一个基础组件，用于线程的休眠和唤醒。

pthread 库中的互斥锁和信号量都是在 futex 的基础上用共享变量来实现的。

### 锁的实现
锁 = 共享变量 + CAS + futex。

锁本质是一个整型变量，通过 CAS 原子操作加减来实现上锁和解锁，失败说明有竞争，此时需要调用 futex 休眠并在条件满足时被唤醒。

加锁和解锁都是通过 CAS 原子操作实现，开销很小；当竞争激烈时，频繁 futex 系统调用，发生内核切换，这是锁的主要开销。

## 读写锁原理
读写锁又叫共享-独占锁，具体实现是基于一个写锁和读引用计数来实现，读的时候要等待写锁，可读时增加引用计数，写的时候等待写锁和引用计数为0，可写时抢占写锁。

### 读方式
- 判断写标志是否在用，在用表示有写操作，内核挂起等待
- 如果不可用，说明当前没有写操作，则读引用计数加1(原子操作)，表示占用资源
- 数据读完，引用计数减1（原子操作），表示释放资源

### 写方式
- 判断写标志是否在用，在用表示有些操作，内核挂起等待；否则设置写标志在用
- 超时时间内等待引用计数是否为0，如果不为0，说明有读操作
- 写共享资源，设置引用计数为0
- 设置写标志不可用，释放资源

## 死锁
### 死锁的产生
多个线程因为争夺资源相互等待，由于存在一种环路的锁依赖关系而永远等待下去，此时的状态称为死锁，比如“哲学家进餐”问题。

一个线程要同时获取两个以上的锁（就好比哲学家进餐里面的两个筷子），如果顺序不对，就有可能产生死锁。

死锁产生的根本原因就是：两个任务以不合理的顺序互相争夺资源。

### 避免死锁
- 按正确的顺序获取锁，比如 Thread1 进入公共方法，获取了锁 A，此时 Thread2 进来了，只能等待锁 A，不能去抢占锁 B，只能等 Thread1 获取锁 B，执行完毕后释放了锁 A 和 B 才能继续执行。

- 超时放弃，当线程获取锁超时则放弃，这样就避免了出现死锁的情况。
- C++ 中可以使用 std::lock_guard<std::mutex> 替代 std::mutex，当 lock_guard 对象析构时，会自动调用 unlock，避免因为异常或者其他原因导致没有执行 unlock 造成死锁。

## 无锁编程
### 自旋锁
当一个线程在获取锁时，如果锁已经被占用，该线程将循环等待，并不断检测锁的状态，直到获取成功为止。

自旋锁不会导致线程和内核切换，适用于短时间等待的场景，linux 内核大量使用了自旋锁，长等待场景会消耗 cpu 空转。

std::mutex 的 try_lock() 方法加锁失败不会执行 futex 挂起线程，可以实现自旋锁。

### 乐观锁
乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。

基于 CAS 原理实现，就是修改数据的时候对数据的版本进行检测判断，如果版本不一致就返回失败。

### ABA 问题
ABA 问题是采用 CAS 都会遇到的问题，是指版本从 A 切换到 B，又从 B 切回 A，场景已经改变，但是 CAS 无法识别导致逻辑错误。

解决办法就是使用版本戳，比如使用时间戳，每次修改对应一个唯一版本。

### RCU 机制
RCU（Read-Copy-Update）采用新旧副本切换机制，旧副本延迟释放，适用写少读多的场景。

## mysql 数据安全性
mysql 对 update 写操作会加行锁，行锁是最小粒度的锁。

### 悲观锁
for updte 语句相当于开启了事务，如果 where 的字段是主键或者索引时为行锁，否则为表锁。

### 乐观锁
在业务逻辑上实现的，不需要额外的锁，增加一个 version 字段，update 时判断版本号。

乐观锁性能会更高，但是乐观锁会存在更新失败回滚和重试的情况，所以失败概率太高时，用乐观锁反而性能不好。
