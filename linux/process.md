# 处理器调度总结
## 进程
进程是资源分配的最小单位，资源包括虚拟内存空间(代码段，数据段，堆)；以及文件描述符、信号等内核资源。

操作系统中用 PCB（process control block）来表示进程，linux 中的 PCB 是 task_struct 结构体。
```
struct task_struct {
	...
     /*PID: 内核进程唯一标识，对应的是线程id*/
     /*tgid：用户进程唯一标识，对应的进程ID，getpid返回该值*/
	 /*内存指针*/
     /* 状态*/
     /* 优先级*/
     /* 程序计数器：下一条指令地址*/
     /* 上下文数据：进程执行时处理器的寄存器数据*/
	...
}
```

### 僵尸进程
子进程退出时，需要父进程 wait 读取子进程的退出状态，然后清理资源，并从进程表中删除。

如果父进程没有 wait 子进程，那么子进程已经结束，但是资源不会被回收，进程表也没有删除，就会成为僵尸进程。

僵尸进程本身没有什么危害，但是如果太多，会导致进程表中有限的进程号被占用，不能产生新的进程。

僵尸进程无法通过 kill -9 杀死，可以先杀死它的父进程，僵尸进程就会被 init 进程接管并回收，正常退出。

### 子进程
父进程通过 fork() 创建子进程，具有以下特点
- 子进程继承父进程的物理内存，当二者任意一个修改内存时，系统会复制一个新的物理内存分配给修改的进程，叫做写时复制。
- 子进程继承父进程打开的文件描述符，此时父子进程共享文件的当前偏移，父进程向文件写内容，子进程接着写会往后追加。

## 线程
线程是系统调度执行的最小单位，线程在内核中和进程一样，也是一个 PCB 结构，同一个进程的多个线程，共享同一个内存指针。

### cpu 亲和性
线程可以与某个逻辑 cpu 绑定，通过设置 cpu 亲和性（affinity）实现。

Linux 内核 2.6 版本之后，支持开发人员通过编程设置 CPU 的硬亲和性（affinity），可以显式地指定线程在哪些处理器上运行。
- 单个线程绑定在一个核上，可以避免 cpu缓 存因切换导致失效，提高缓存命中率。
- 两个数据相关的线程绑定到一个核上，可以共享 cpu 缓存，提高缓存命中率。

### 进程和线程的区别
- 进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。
- 进程拥有独立的代码和数据空间；线程拥有独立运行的栈和程序计数器。
- 线程一定归属某个进程，线程间可共享进程内部的系统资源（内存数据，文件描述符）；进程至少要有一个主线程。
- 在内核中，二者都是 task_struct 进程对象，调度时统一称为进程调度，主线程的线程号也是进程号。

## 进程调度
处理器的调度是以线程为单位的，但是内核中，线程是一个 task_struct 对象，笼统上也叫进程，所以线程调度也叫进程调度。

### 调度的发生
- 主动调度：程序执行 sleep，IO 阻塞操作，锁操作 wait，都会主动让出 cpu 执行权，发生一次 cpu 切换。
- 被动调度：线程任务的时间片用完；有优先级更高的任务。

### 调度的开销
- cpu 执行任务调度的开销，主要是 cpu 上下文切换的开销（寄存器和程序计数器的保存和恢复）。
- 当两个不同进程的任务之间产生调度，cpu cache 和 TLB（页表缓存）不命中，导致 cache miss 和缺页中断。

### 进程调度算法（CFS）
linux 内核 2.6 之后，普通进程的调度算法采用的是 CFS（Completely Fair Scheduler 完全公平调度算法)。

- CFS 通过计算进程消耗的 cpu 时间（vruntime）来分配调度，vruntime = 实际运行时间 * 1024 / 进程权重。

- linux 采用一颗红黑树，记录下每一个进程的 vruntime，需要调度时，从红黑树中取出一个 vruntime 最小的进程出来运行。

- 进程权重由 nice 值决定，每个进程对应一个 nice 值，nice 值越大，权重越低。

- 休眠进程被唤醒时，会重新初始化 vruntime，在 min_vruntime （初始时间）基础之上作出少量的补偿，所以 IO 密集型进程比计算密集型进程拥有更高的调度权。
