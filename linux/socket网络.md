# TCP 可靠传输原理
## 概述
TCP 是传输层的协议，全称是叫做 Transmission Control Protocol。

### TCP 特点
- 面向连接：在数据传输之前，通信双方需要先建立一个可信的连接。
- 可靠传输：通过 ”ack 确认“和”超时重传“两种机制，保证消息的可靠送达。
- 流式传输：传输的数据不关心应用层的消息边界。
- 全双工：数据同时在两个方向上传输。

## TCP 数据包
#### TCP 的报文格式如下

![tcp_data](images/tcp_data.png)

#### 源端口
源端口表明发送端所使用的端口号，用于目标主机回应。

#### 目的端口
表明要连接的目标主机的端口号。

#### 序号
表明发送的数据包的顺序，一般为上次发送包中的顺序号+1，第一个 SYN 包的序号值是随机生成的。

#### 确认号
表明本端 TCP 已经接收到的数据，其值表示期待对端发送的下一个字节的序号，第一个 SYN 包的确认号一般为 0。

#### 数据偏移
表示 4 字节为单位的 TCP 报文的包头长度，用于确定用户数据区的起始位置。TCP 头部的大小为 20 字节，对应该值为 5。

#### 紧急标志位(URG)
开启时表明此数据包处于紧急状态应该优先处理

#### 确认标志位(ACK)
开启时表明确认号有效，否则忽略确认号

#### 推送标志位(PSH)
开启时表明应该尽快交付给应用进程，而不必等到缓存区填满才推送。

#### 复位标志位(RST)
开启时表明TCP连接出现错误，数据包非法拒绝连接。

#### 同步标志位(SYN)
建立连接的标志

#### 终止标志位(FIN)
开启时表明释放一个连接

#### 窗口大小
表明期望接受到的数据包字节数，用于拥塞控制。

#### 校验和
实现对TCP报文头以及数据区进行校验。

## TCP 工作流程
![tcp_conn](images/tcp_conn.jpg)

### 三次握手
三次握手的过程是，通信双方互相告知确认自己发送数据的序列号起始值（随机产生），序列号用来标识已发送的数据。

如果只是两次握手，至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。

#### 半连接队列
服务端收到 SYN 消息后进入 SYN-RECV 状态并等待客户端 ACK，此时连接为半连接，会写入服务端的半连接队列。

```
// 设置半连接队列的默认长度
echo 4096 > /proc/sys/net/ipv4/tcp_max_syn_backlog
```

#### syn flood 攻击
利用 TCP 三次握手的漏洞，短时间内向服务端发送大量 SYN 包而不响应，那么服务器的半连接队列很快会被写满，导致无法工作。

实现 syn flood 的手段，可以通过伪造源 IP 的方式，这样服务器的响应就永远到达不了客户端（握手无法完成）。

对 syn flood 实现拦截是比较困难的，最好的办法是通过专业的防火墙来解决。

#### 全连接队列
当服务端收到客户端的 ACK 后，连接建立，半连接会变成全连接，并转移到全连接队列中，对于全连接队列，如果服务器未能及时通过 accept 调用将其中的连接取走，会导致队列溢出。

全连接队列的长度会限制服务器的并发，队列的长度通过内核配置和 listen 时 backlog 参数设置，取二者的最小值，默认 1024、
```
// 内核设置
echo 4096 > /proc/sys/net/core/somaxconn
```

### 四次挥手
在连接关闭时，由于 TCP 是全双工的，通信双方需要根据业务逻辑分别关闭各自发送端，所以需要四次挥手。

#### 半关闭状态
A 调用 close 关闭连接，而对端 B 没有调用 close 关闭，A 和 B 的连接就处于半关闭状态。
```
A -----FIN-----> B
FIN_WAIT_1       CLOSE_WAIT
A <----ACK------ B
FIN_WAIT_2
```

CLOSE_WAIT 状态的连接过多是不正常的，原因可能是出现了连接泄露 BUG，或者压力过大，来不及 close()。

#### TIME_WAIT 状态
A 调用 close 关闭连接，B 收到 FIN 后也调用 close 关闭连接，A 收到 B 的 FIN 后，会进入 TIME_WAIT 状态，并发送 ACK 给 B。
```
A -----FIN-----> B
FIN_WAIT_1       CLOSE_WAIT
A <----ACK------ B
FIN_WAIT_2

(B can send more data here, this is half-close state)

A <----FIN------ B
TIME_WAIT        LAST_ACK
A -----ACK-----> B
|                CLOSED
2MSL Timer
|
CLOSED
```

#### TIME_WAIT 作用
##### 保证连接正常释放
A 发送的 ACK 如果丢失，B 会重发 FIN，此时如果 A 的连接被关闭，TCP 传输层会返回 B 一个 RST 错误，影响关闭流程。维护一个 TIME_WAIT 状态可以重发 ACK，让对端 B 正常释放。

##### 避免旧数据包影响新连接
TCP 使用四元组来区分一个连接，如果 A 端不经过 TIME_WAIT 直接关闭，B 马上发起一个新的连接，新连接四元组和旧连接完全一样，TCP 无法区分新旧连接，这个时候网络中存在的旧数据包到来后会影响新的连接，而等待 TIME_WAIT 之后，可以保证新连接（相同四元组）建立后，网络中没有残存的旧数据包。

#### TIME_WAIT 持续时间
TIME_WAIT 状态持续 2MSL（1分钟），MSL（Max Segment Lifetime）是数据包在网络中传输的最大生命周期，默认 30 秒。

2MSL 时间到达后，连接会被关闭，此时如果又收到来自 B 的 FIN，则会返回 RST 错误，B 收到 RST 后关闭连接。

MSL 的大小可以根据网络状况设置，网络状态好时 MSL 可以设置短一点。

#### TIME_WAIT 危害
频繁主动关闭连接，会产生大量的 TIME_WAIT，这些连接仍占用文件描述符和少量内存（4K），如果是客户端还会占用1个本地端口。

##### 解决方案
可以使用长连接，避免连接的频繁关闭，还可以修改内核参数
```
net.ipv4.tcp_tw_reuse = 0    表示开启端口重用（只针对客户端connect有效）
net.ipv4.tcp_tw_recycle = 0  表示开启快速回收（慎用，在 NAT 环境下会出现丢包导致连接失败）
```
- 针对客户端，主要解决端口耗尽问题，可打开 tcp_tw_reuse 设置，不建议打开 tcp_tw_recycle，帮助不大。
- 作为服务端，主要是文件描述耗尽问题，没有什么办法解决，不建议打开 tcp_tw_recycle，除非确保服务器不是 NAT 网络。
