# linux 处理器管理
## cpu 管理
### 物理 cpu
主板上实际插入的 cpu 数量，查看物理 cpu 个数
```
cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l
```

### cpu 核心
cpu 的组成是由运算器和控制器组成，每个核心都有一组控制器和运算器，查看每个物理 cpu 的核心数
```
cat /proc/cpuinfo |grep "cores"|uniq
```

### 逻辑 cpu
Top 命令中显示的 cpu，代表可独立执行的单元。

逻辑 cpu 个数 = 物理 CPU 个数 * 每个物理 CPU 的核心数 * 超线程数量
```
cat /proc/cpuinfo| grep “processor”|wc -l
```

### cpu 负载
通过 top 查看 load average，3个值分别代表1分钟，5分钟，15分钟的load情况，重点关注的是后两个。

load average 是一段时间内处于可运行状态和不可中断状态的进程平均数量，该值等于逻辑cpu个数时，说明各个核心刚好打满，也没有排队现象，超过cpu个数时说明负载变高，有进程排队等待。

### cpu 利用率
cpu利用率代表cpu时间的占用多少，top命令查看时，如果是4个逻辑cpu，则cpu利用率最高是400%。

cpu利用率和cpu负载没有直接关系，cpu利用率反应的是cpu的占用时间，load反应的是执行cpu运算的任务平均数。

- IO密集型服务：cpu负载高但是利用率低，等待的进程过多(比如磁盘I/O等待)，导致进程队列长度过大，但是cpu运行的进程却很少，这样就体现到负载过大了，cpu使用率低。
- 计算密集型服务：任务少，但是任务执行占用cpu时间很长，比如死循环。

### 排查 cpu 热点
```
找出占用率高的线程

top -H -p 进程id


查看系统调用堆栈，找到对应的线程，分析上下文问题
pstack 进程id


利用strace跟踪具体线程的系统调用
strace -p 线程id

查看系统调用和花费时间，找出最占用cpu的系统调用
strace -T -r -c -p 线程id
```

## cpu 缓存
cpu 缓存是 cpu 自带的高速存储器，根据访问速度和容量大小分为三级缓存（L1，L2，L3）。

cpu 缓存是为了解决 cpu 时钟周期和主存（RAM）访问速度不匹配的问题。

缓存和主存之间，数据是按固定大小的块传输的，该块称为缓存行（cache line），一般一个 cache line 占 64 字节。

### 三级缓存
cpu 的缓存分三级，访问顺序依次为：L1 -> L2 -> L3 -> 主存(RAM)。
- L1缓存：速度最快(1ns)；容量最小(32K)；对应每个物理线程（可以通过超线程技术，将1个核心模拟成多个物理线程）
- L2缓存：速度其次(3ns)；容量其次(256k)；对应每个cpu核，同一个核下的多个物理线程共享一个L2缓存
- L3缓存：速度最慢(12ns)；容量最大(30M)；对应每个cpu插槽；同一个物理cpu共享一个L3缓存。

### 缓存一致性协议（MESI）
处理器多个物理线程对同一块主存数据更改时，会导致各自的缓存数据不一致，通过 MESI 协议来保证各个缓存的最终一致性。

在 MESI 协议中，每个缓存行不仅知道自己的读写操作，而且也监听其它缓存行的读写操作。每个缓存行的状态根据本 cpu 和其它 cpu 的读写操作在4个状态间进行迁移。

当某个cpu修改缓存行数据时，其他的cpu通过监听机制获悉共享缓存行的数据被修改，会使其共享缓存行失效。本cpu会将修改后的缓存行写回到主内存中。此时其他的cpu如果需要此缓存行共享数据，则从主内存中重新加载，并放入缓存，以此完成了缓存一致性。

#### MESI 状态
- Modify（修改）：该缓存行只出现在当前 cpu 中，缓存已经被修改，和主存不一致，等待同步到主存；监听到其他cpu的读取操作时，写回主存，并设置为 Shared 状态、
- Exclusive（独占）：该缓存行只出现在当前 cpu 中，已经同步到主存；此时监听到其他 cpu 的读取操作，将状态改为 Shared。
- Shared（共享）：该缓存行可能出现在多个 cpu 中，而且多个缓存的数据和主存一致；监听其他 cpu 的写操作，一旦监听到，将状态标记为 Invalid 状态。
- Invalid（失效）：其他cpu修改了缓存行，导致本 cpu 中的缓存行失效。

## cpu 上下文切换
### cpu 上下文
- cpu 寄存器：cpu 内置的容量小、速度极快的内存；cpu 通过各种寄存器（比如加法器）来完成运算。
- 程序计数器：用来存储 cpu 正在执行的指令或者下一条指令，程序计数器也属于 cpu 内置的寄存器。

### 上下文切换
把前一个任务的 cpu 上下文保存下来，然后加载新任务的上下文到这些寄存器和程序计数器中。

任务的 cpu 上下文被保存到内核中，当再次被调度执行的时候，需要重新恢复寄存器和程序计数器的数据，让任务可以连续执行。

cpu 上下文切换太频繁，导致 cpu 时间消耗在上下文数据的保存和恢复上，导致系统性能下降。

#### 查看系统上下文切换
```
vmstat 5
cs（context switch）每秒上下文切换次数
in（interrupt）每秒中断次数
r （running or runnable）正在运行和等待CPU进程数
b（blocked）不可中断睡眠状态的进程数
```

#### 查看进程的上下文切换
```
pidstat -w
cswch（voluntary context switches）自愿上下文切换：进程无法获取所需资源，导致上下文切换。比如I/O，内存等系统资源不足时会发生自愿上下文切换。
nvcswch（non voluntary context switches）非自愿上下文切换：进程由于时间片已到等原因，被系统强制调度，发生上下文切换。比如大量进程都在争抢CPU时，就容易发生非资源上下文切换。
```
