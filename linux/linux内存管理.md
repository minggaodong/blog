# linux 内存管理

## 物理内存
### 查看内存使用
```
free -h
```
![free](images/free.png)
- available：代表当前可以用的空闲内存，约等于 free + buff/cache。
- buff/cache：块设备读写缓冲区和文件系统的页缓存，buff/cache 可以降低磁盘IO，提高读写效率。当内存不足时，buff/cache 的数据会被系统回收，系统会比较内存和磁盘文件是否一致，不一致要回写磁盘文件，此时磁盘IO占用会很高。

#### 页缓存（page cache）
页缓存属于物理内存，是内核访问磁盘的高速缓存，应用程序读写文件时，都是直接访问页缓存，操作系统负责页缓存与磁盘文件的数据同步。

程序 read 文件时，内核先读取页缓存，如果没查到，则通过 DMA 的方式将数据从磁盘拷贝到页缓存，不占用 cpu。

程序 write 文件时，内核首先将数据拷贝到页缓存，并异步返回成，操作系统保证将脏页数据回写到磁盘（通过定时定量机制），关闭文件也不会触发刷新磁盘。

##### 清空页缓存
```
echo 1 > /proc/sys/vm/drop_cach
```
- 0：不释放（系统默认值）
- 1：释放页缓存
- 2：释放dentries和inodes
- 3：释放所有缓存


#### 页缓存异步刷新配置
```
sysctl -a | grep dirty
vm.dirty_background_bytes = 0
vm.dirty_background_ratio = 5
vm.dirty_bytes = 0
vm.dirty_expire_centisecs = 3000      # 表示脏数据多久会被刷新到磁盘上。这里的3000表示 30秒。
vm.dirty_ratio = 10                   # 当脏页占用的内存百分比超过此值时，内核会阻塞掉写操作，并开始刷新脏页。
vm.dirty_writeback_centisecs = 500    # 表示多久唤醒一次刷新脏页的后台线程。这里的500表示5秒唤醒一次。
```

#### swap
swap 相当于 windows 下的虚拟内存，当内存不够时，通过 LRU 页面置换算法将暂时不用的内存先移到磁盘，把物理内存释放出来，当进程需要访问这些数据时，再从磁盘加载到内存。

swap 是为了解决物理内存不足时，用磁盘置换来腾出可用内存，频繁交换会降低系统性能。swap 不建议关闭，当关闭 swap 后，如果物理内存不足时，程序会因为内存不够而 crash。
```
# 查看swappiness参数
cat /proc/sys/vm/swappiness

# 修改swappingness参数
vim /etc/sysctl.conf  # 打开系统配置
vm.swappiness = 10    # 可用内存剩余10%时开启swap
sysctl -p             # 使生效

# 刷新释放swap空间
swapoff -a && swapon -a
```

## 物理内存分配
linux 通过分段和分页机制，把物理内存划分 4k 大小的内存页（也叫页框），物理内存的分配和回收都是基于页框进行。

### 内存碎片
#### 框外碎片
频繁的分配与回收物理页会导致大量小块内存夹杂在已分配的页框中间，形成框外碎片。

#### 框内碎片
一个物理页框大小4k，分配小内存也会占用一个页框，造成浪费，这就是内部碎片。

#### 伙伴系统
linux 采用伙伴系统（Buddy system）来解决框外碎片问题。

将空闲页框分组为 11 个块链表，每个块链表的块包含的连续页框个数依次为1,2，...1024，分配的时候寻找大小合适的块链表。

#### slab 分配器
slab 解决内核小对象分配太多产生的内部碎片问题。

slab 工作在伙伴系统之上，管理内核小对象，通过实现的缓存池，避免内部碎片；同时减少内存分配次数。

## 虚拟内存分配
虚拟内存解决多进程地址冲突问题，每个进程都可以拥有 2^64 的地址空间，虚拟内存也是按照 4k大小划分成页（page）。

### 缺页中断
通过 malloc 分配的虚拟内存还没有分配物理内存，只有当访问时，产生缺页中断，才会通过伙伴系统和 slab 分配器申请物理内存。

### 页表
每个进程都有一个页表，保存虚拟内存到物理内存的映射。

### malloc 分配
malloc 申请内存小于 128KB 时，使用 brk 或 sbrk 通过移动堆顶指针分配内存，大于 128KB 时，使用 mmap 在文件映射区申请。

由于 brk/sbrk/mmap 属于系统调用，会导致 cpu 在用户态和内核态之间切换，影响性能。

malloc 采用内存池提供性能，将一大块内存分成不同大小的块，用户申请时，从空闲链表中选择一个大小相近的块分配。
![malloc](images/malloc.png)

#### 内存碎片
堆是从低地址往高地址增长，如果低地址的内存没有被释放，高地址的内存就不能被回收，容易产生内存碎片。

小内存块太多，且相邻内存块一直使用导致无法合并成大内存块，内存块因为太小，很难被再利用上，产生碎片。

内存碎片会导致系统变慢，内存碎片不可避免，只能尽量减少，避免使用小内存，尽量用内存池。

## 进程内存模型
内存地址从高到底依次
- 用户栈：系统为每个线程分配一个 8M 的栈空间，栈上分配内存是从高地址向低地址分配。
- 文件映射区：通过 mmap() 分配的地址区，动态库也在这个区间，动态库只共享代码段，不共享数据段。
- 堆区：存储动态分配的内存，大小不固定。
- 读写数据段：通常已初始化的全局变量和局部静态变量被放在了读写数据段。
- 只读数据段：C 语言中的只读全局变量，程序中使用的字符串常量等会在编译时被放入到只读数据区。
- 代码段：程序的二进制代码

### 内存泄露
发生内存泄露时，通过 top 查看 Virt 虚拟内存占用会持续增长，Res 物理内存占用一般也相应的增长。
```
# 查看虚拟内存Vmsize大小
cat /proc/943/status |grep VmSize # 如果Vsize一直涨，说明存在泄露
```

#### 避免内存泄露
- 避免在堆上分配内存，尽量在栈上分配。
- 使用智能指针。

### mmap内存映射
mmap 将文件直接映射到用户空间，进程可以像访问普通内存一样直接对文件进行访问。
- 普通IO操作，需要通过 read 将数据从页缓存拷贝到用户缓冲区后才能使用。
- mmap 可以减少 read 时内核页缓存到用户缓冲区的拷贝，但是写操作还是需要从用户缓冲区拷贝到页缓存。
- 多个进程通过映射同一个文件，可以实现共享内存，这也是mmap的主要用途。
- mmap内存映射，可以实现磁盘文件发送到socket时的零拷贝技术。
